{"version":3,"sources":["components/Panel/GenerateMazeDropdown.js","components/Panel/PathfindingAlgorithmDropdown.js","components/Cell/Cell.js","components/Panel/Dropdown.js","util/createCell.js","util/createBoard.js","util/mazeDFS.js","util/pathfinderBFS.js","util/toolsForAlgorithms.js","util/pathfinderDijkstra.js","util/pathfinderAstar.js","util/pathfinderDFS.js","util/mazeRandom.js","components/Board/Board.js","components/Footer/Footer.js","App.js","index.js"],"names":["GenerateMazeDropdown","props","_React$useState","React","useState","_React$useState2","Object","slicedToArray","isOpen","setIsOpen","handleDFSMaze","handleRandomMaze","react_default","a","createElement","reactstrap_module","toggle","color","caret","onClick","PathfindingAlgorithmDropdown","handleBFSPathfinder","handleDFSPathfinder","handleAstarPathfinder","handleDijkstraPathfinder","Cell","x","y","isFinish","isStart","isBaseWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","className","id","concat","Dropdown","options","header","handleDropdown","map","option","i","key","createCell","j","finish","isWallToDestroy","visited","previousNode","distance","Infinity","distanceToFinishNode","Math","abs","createBoard","row","col","start","grid","push","getNeighbour","current","notVisited","filter","c","length","rndNeighborPosition","floor","random","destroyWall","next","diffX","diffY","mazeDFS","createInitialBoardForDFS","rows","cols","getVisitedCellsFromDFS","stack","visitedCellsInOrder","wallDestroyed","pop","pathfinderBFS","startNode","finishNode","visitedNodesInOrder","queue","shift","getAllNodes","_step","nodes","_iterator","_createForOfIteratorHelper","s","n","done","_step2","_iterator2","value","node","err","e","f","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","getUnvisitedNeighbours","neighbours","neighbor","pathfinderDijkstra","closestNode","updateUnvisitedNeighbours","pathfinderDijkstra_createForOfIteratorHelper","pathfinderAstar","pathfinderAstar_createForOfIteratorHelper","pathfinderDFS","mazeRandom","createInitialBoardForRandomMaze","getRandomCells","WIDTH","HEIGHT","START","FINISH","Board","_useState","_useState2","dropdownSpeedHeader","setdropdownSpeedHeader","_useState3","_useState4","message","setMessage","_useState5","_useState6","extraMessage","setExtraMessage","_useState7","_useState8","boardVisualizationMessage","setBoardVisualizationMessage","_useState9","_useState10","speed","setSpeed","_useState11","_useState12","setGrid","_useState13","_useState14","isVisualizing","setIsVisualizing","timeoutID","useRef","prepareGridForAlgorithms","newGrid","Board_createForOfIteratorHelper","cell","document","getElementById","visualize","shortestPathCells","_loop","setTimeout","_loop2","visualizeShortestPath","getStart","getFinish","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","clearGrid","slice","useEffect","newBoard","freshBoard","clearTimeout","_loop3","undefined","dropdownInfo","singleRow","singleBlock","Cell_Cell","Footer","role","aria-label","href","App","components_Board_Board","Footer_Footer","ReactDOM","render","StrictMode","src_App"],"mappings":"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","file":"static/js/main.ac721df4.chunk.js","sourcesContent":["import React from \"react\";\nimport { ButtonDropdown, DropdownToggle, DropdownMenu, DropdownItem, } from 'reactstrap';\n\nexport default function GenerateMazeDropdown(props){\n    const [isOpen, setIsOpen] = React.useState(false) \n    var handleDFSMaze = props.handleDFSMaze;\n    var handleRandomMaze = props.handleRandomMaze;\n    function toggle(){\n        setIsOpen(!isOpen)\n    }\n    return(\n        \n            <ButtonDropdown\n                isOpen={isOpen}\n                toggle={toggle}>\n                <DropdownToggle color=\"primary\" caret>\n                    Generate Maze\n                </DropdownToggle>\n                <DropdownMenu>\n                    <DropdownItem onClick={()=> {handleDFSMaze()}}>Depth-First-Search</DropdownItem>\n                    <DropdownItem onClick={()=> {handleRandomMaze()}}>Random Maze</DropdownItem>\n                </DropdownMenu>\n            </ButtonDropdown>\n        \n        \n    );\n}","import React from \"react\";\nimport { ButtonDropdown, DropdownToggle, DropdownMenu, DropdownItem, } from 'reactstrap';\n\nexport default function PathfindingAlgorithmDropdown(props){\n    const [isOpen, setIsOpen] = React.useState(false) \n    var handleBFSPathfinder = props.handleBFSPathfinder;\n    var handleDFSPathfinder = props.handleDFSPathfinder;\n    var handleAstarPathfinder = props.handleAstarPathfinder;\n    var handleDijkstraPathfinder = props.handleDijkstraPathfinder;\n\n    function toggle(){\n        setIsOpen(!isOpen)\n    }\n    return(\n        \n            <ButtonDropdown\n                isOpen={isOpen}\n                toggle={toggle}>\n                <DropdownToggle color=\"primary\" caret>\n                    Choose Pathfinding Algorithm\n                </DropdownToggle>\n                <DropdownMenu>\n                    <DropdownItem onClick={()=>{handleBFSPathfinder()}}>Breadth-First search</DropdownItem>\n                    <DropdownItem onClick={()=>{handleDFSPathfinder()}}>Depth-First search</DropdownItem>\n                    <DropdownItem onClick={()=>{handleDijkstraPathfinder()}}>Dijkstra search</DropdownItem>\n                    <DropdownItem onClick={()=>{handleAstarPathfinder()}}>A star search</DropdownItem>\n                </DropdownMenu>\n            </ButtonDropdown>\n       \n        \n    );\n}","import React from \"react\";\nimport './Cell.css'\n\nexport default function Cell(props) {\n  const {\n    x,\n    y,\n    isFinish,\n    isStart,\n    isBaseWall,\n    onMouseDown, \n    onMouseEnter, \n    onMouseUp, \n    onMouseLeave    \n  } = props;\n  const className= \"cell\" + (isStart? \" isStart\": \"\") + (isFinish? \" isFinish\": \"\") + (isBaseWall? \" isBaseWall\": \"\") //+ (visited? \" visited\": \"\")\n  return <div id={`cell-${y}-${x}`} \n              className={className}\n              onMouseDown={() => onMouseDown(y, x)}\n              onMouseEnter={() => onMouseEnter(y, x)}\n              onMouseUp={() => onMouseUp(y, x)}\n              onMouseLeave={() => onMouseLeave(y, x)}></div>;\n}\n\n\n","import React from \"react\";\nimport { ButtonDropdown, DropdownToggle, DropdownMenu, DropdownItem, } from 'reactstrap';\n\nexport default function Dropdown(props){\n    const options = props.options;\n    const header = props.header;\n    const [isOpen, setIsOpen] = React.useState(false) \n    var handleDropdown = props.handleDropdown;\n    function toggle(){\n        setIsOpen(!isOpen)\n    }\n    // function handleDropdown(dropdownClickInfo){\n    //     props.handleDropdown();\n    // }\n    return(\n        <ButtonDropdown\n        isOpen={isOpen}\n       toggle={toggle}>\n       <DropdownToggle color=\"primary\" caret>\n           {header}\n       </DropdownToggle>\n       <DropdownMenu>\n       {options.map((option, i) => (\n                    <DropdownItem  key={i}\n                                   onClick={()=>handleDropdown({header, option})}\n                    >\n                        {option}\n                    </DropdownItem>\n                ))}\n       </DropdownMenu>\n       </ButtonDropdown>\n    );\n}","export default (i, j, finish) =>{\n    return {\n        x: j,\n        y: i,\n        isWallToDestroy: false,\n        isBaseWall: false,\n        isStart: false,\n        isFinish: false,\n        visited: false,\n        previousNode: null,\n        distance: Infinity,\n        distanceToFinishNode: Math.abs(finish.y - i) + Math.abs(finish.x - j)\n    }\n}","import createCell from \"./createCell\";\nexport default (row, col, start, finish) => {\n  let grid = [];\n        for (let i = 0; i < row; i++) {\n            grid.push([]);\n            for (let j = 0; j < col; j++) {\n                grid[i][j] = createCell(i, j, finish);\n            }\n        }\n        grid[start.y][start.x].isStart = true;\n        grid[finish.y][finish.x].isFinish = true;\n        return grid;\n};\n","import createCell from \"./createCell\";\nexport function createInitialBoardForDFS (rows, cols, start, finish) {\n    let grid = [];\n    for (let i = 0; i < rows; i++) {\n        grid.push([]);\n        if(i%2===0){\n            for (let j = 0; j < cols; j++) {\n                grid[i][j] = createCell(i, j, finish);\n                grid[i][j].isBaseWall = true;\n            }\n        }else{\n            for (let j = 0; j < cols; j++) {\n                if(j%2===0){\n                    grid[i][j] = createCell(i, j, finish);\n                    grid[i][j].isBaseWall = true;\n\n                }else{\n                    grid[i][j] = createCell(i, j, finish);\n                }\n            }\n        }\n    }\n    grid[start.y][start.x].isStart = true;\n    grid[start.y][start.x].isBaseWall = false;\n    grid[finish.y][finish.x].isFinish = true;\n    grid[finish.y][finish.x].isBaseWall = false;\n    return grid;\n}\n\n//apply dfs to the grid \nexport function getVisitedCellsFromDFS(grid){\n    let current = grid[1][1];\n    let stack = [current];\n    let visitedCellsInOrder = [];\n    while(stack.length){\n        current.visited = true;\n        visitedCellsInOrder.push(current);\n        // get possible neighbour\n        let next = getNeighbour(current, grid);\n        if(next != null){\n            next.visited = true;\n            //destroy wall\n            let wallDestroyed = destroyWall(current, next, grid);\n            visitedCellsInOrder.push(wallDestroyed);\n            //push current to stack\n            stack.push(current);\n            current = next;\n        }else{\n            // if no neighbours found, start backtracking using the stack \n            current = stack.pop();\n        }\n    }\n    visitedCellsInOrder.push(\"end\");\n    return visitedCellsInOrder;\n}\nfunction getNeighbour(current, grid){\n    let neighbours = [[current.y - 2, current.x],\n                      [current.y + 2, current.x],\n                      [current.y, current.x+2],\n                      [current.y, current.x-2]];\n    let notVisited = neighbours.filter(c => (\n                                              c[0] > 0 && c[1] > 0\n                                              && c[0] < grid.length && c[1] < grid[0].length\n                                              && !grid[c[0]][c[1]].visited\n                                            ));\n    if(notVisited.length){\n        let rndNeighborPosition = notVisited[Math.floor(Math.random() * notVisited.length)];\n        let rndNeighbor = grid[rndNeighborPosition[0]][rndNeighborPosition[1]];\n        return rndNeighbor;\n    }else return null;\n}\n\nfunction destroyWall(current, next, grid){\n    //compare cells on x axis\n    let diffX = current.x - next.x;\n    if(diffX === 2){\n        grid[next.y][next.x + 1].isWallToDestroy = true;\n        return grid[next.y][next.x + 1];\n    }else if(diffX === -2){\n        grid[next.y][next.x - 1].isWallToDestroy = true;\n        return grid[next.y][next.x - 1];\n    }\n    //compare cells on y axis\n    let diffY = current.y - next.y;\n    if(diffY === 2){\n        grid[next.y + 1][next.x].isWallToDestroy = true;\n        return grid[next.y + 1][next.x];\n    }else if(diffY === -2){\n        grid[next.y - 1][next.x].isWallToDestroy = true;\n        return grid[next.y - 1][next.x];\n    }\n}\nexport default {createInitialBoardForDFS, getVisitedCellsFromDFS}\n\n","// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport default (grid, startNode, finishNode) => {\n    const visitedNodesInOrder = [];\n    let queue = [startNode];\n    while (queue.length) {\n        const current = queue.shift();\n        if (current === finishNode) {\n            return visitedNodesInOrder;\n        }\n        if (!current.isBaseWall && (current.isStart || !current.visited)) {\n            current.visited = true;\n            visitedNodesInOrder.push(current);\n            const {x, y} = current;\n            let next;\n            if (y > 0) {\n                next = grid[y - 1][x];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    queue.push(next);\n                }\n            }\n            if (y < grid.length - 1) {\n                next = grid[y + 1][x];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    queue.push(next);\n                }\n            }\n            if (x > 0) {\n                next = grid[y][x - 1];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    queue.push(next);\n                }\n            }\n            if (x < grid[0].length - 1) {\n                next = grid[y][x + 1];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    queue.push(next);\n                }\n            }\n        }\n    }\n}\n  ","function getAllNodes(grid){\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n        nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    const neighbours = [];\n    const { y, x } = node;\n    if (y > 0)\n      neighbours.push(grid[y - 1][x]);\n    if (y < grid.length - 1)\n      neighbours.push(grid[y + 1][x]);\n    if (x > 0)\n      neighbours.push(grid[y][x - 1]);\n    if (x < grid[0].length - 1)\n      neighbours.push(grid[y][x + 1]);\n    return neighbours.filter(neighbor => !neighbor.visited);\n}\n\nexport {getAllNodes, sortNodesByDistance, getUnvisitedNeighbours}","import { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours} from \"./toolsForAlgorithms\";\n\nexport default (grid, startNode, finishNode) => {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        // If we encounter a wall, we skip it.\n        if (!closestNode.isBaseWall) {\n            if (closestNode.distance === Infinity)\n              return visitedNodesInOrder;\n            \n            closestNode.visited = true;\n            visitedNodesInOrder.push(closestNode);\n            // if the finsih node is reached then we return the visitedNodes array\n            if (closestNode === finishNode)\n              return visitedNodesInOrder;\n            \n            updateUnvisitedNeighbours(closestNode, grid);\n        }\n    }\n}\n\nfunction updateUnvisitedNeighbours(node, grid){\n    const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}","import { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours} from \"./toolsForAlgorithms\";\n\nexport default (grid, startNode, finishNode) => {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        // If we encounter a wall, we skip it.\n        if (!closestNode.isBaseWall) {\n            if (closestNode.distance === Infinity)\n              return visitedNodesInOrder;\n            \n            closestNode.visited = true;\n            visitedNodesInOrder.push(closestNode);\n            // if the finsih node is reached then we return the visitedNodes array\n            if (closestNode === finishNode)\n              return visitedNodesInOrder;\n            \n            updateUnvisitedNeighbours(closestNode, grid);\n        }\n    }\n}\n\nfunction updateUnvisitedNeighbours(node, grid){\n    const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n        neighbor.previousNode = node;\n    }\n}","// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport default (grid, startNode, finishNode) => {\n    const visitedNodesInOrder = [];\n    let stack = [startNode];\n    while (stack.length) {\n        const current = stack.pop();\n        if (current === finishNode) {\n            return visitedNodesInOrder;\n        }\n        if (!current.isBaseWall && (current.isStart || !current.visited)) {\n            current.visited = true;\n            visitedNodesInOrder.push(current);\n            const {x, y} = current;\n            let next;\n            if (y > 0) {\n                next = grid[y - 1][x];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    stack.push(next);\n                }\n            }\n            if (y < grid.length - 1) {\n                next = grid[y + 1][x];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    stack.push(next);\n                }\n            }\n            if (x > 0) {\n                next = grid[y][x - 1];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    stack.push(next);\n                }\n            }\n            if (x < grid[0].length - 1) {\n                next = grid[y][x + 1];\n                if (!next.visited) {\n                    next.previousNode = current;\n                    stack.push(next);\n                }\n            }\n        }\n    }\n}\n  ","import createCell from \"./createCell\";\n\nexport function createInitialBoardForRandomMaze(rows, cols, start, finish) {\n    let grid = [];\n    for (let i = 0; i < rows; i++) {\n        grid.push([]);\n        for (let j = 0; j < cols; j++) {\n            grid[i][j] = createCell(i, j, finish);\n        }\n    }\n    grid[start.y][start.x].isStart = true;\n    grid[start.y][start.x].isBaseWall = false;\n    grid[finish.y][finish.x].isFinish = true;\n    grid[finish.y][finish.x].isBaseWall = false;\n    return grid;\n}\n\n//apply random to the grid\nexport function getRandomCells(grid){\n    let visitedCellsInOrder = [];\n    for(let i=0; i<grid.length; i++){\n        for(let j=0; j<grid[0].length; j++){\n            if(Math.random() < 0.2 && (!grid[i][j].isStart || !grid[i][j].isFinish)){\n                grid[i][j].isBaseWall = true;\n                visitedCellsInOrder.push(grid[i][j]);\n            }\n        }\n    }\n    visitedCellsInOrder.push(\"end\");\n    return visitedCellsInOrder;\n}\n\nexport default {createInitialBoardForRandomMaze, getRandomCells}\n\n","import React, { useEffect, useState, useRef } from \"react\";\nimport { Button, ButtonGroup,} from \"reactstrap\";\n//components\nimport GenerateMazeDropdown from \"../Panel/GenerateMazeDropdown\";\nimport PathfindingAlgorithmDropdown from \"../Panel/PathfindingAlgorithmDropdown\";\nimport Cell from \"../Cell/Cell\";\nimport Dropdown from \"../Panel/Dropdown\";\n//utils\nimport createBoard from \"../../util/createBoard\";\nimport mazeDFS from \"../../util/mazeDFS\";\nimport pathfinderBFS from \"../../util/pathfinderBFS\";\nimport pathfinderDijkstra from \"../../util/pathfinderDijkstra\";\nimport pathfinderAstar from \"../../util/pathfinderAstar\";\nimport pathfinderDFS from \"../../util/pathfinderDFS\";\nimport mazeRandom from \"../../util/mazeRandom\";\n//styles\nimport \"./Board.css\";\n\n//constants\nconst WIDTH = 31; \nconst HEIGHT = 21;\nconst START = {x: 1, y: 0}\nconst FINISH = {x: (WIDTH-2), y: (HEIGHT-1)}\n\nconst Board = () => {\n  const speedOptions=[\"Slow\", \"Medium\", \"Fast\", \"Extra-Fast\"]\n  const [dropdownSpeedHeader, setdropdownSpeedHeader] = useState(\"Speed: Extra-Fast\");\n  const [message, setMessage] = useState(\"Maze Generator and Pathfinder Tool!\");\n  const [extraMessage, setExtraMessage] = useState('');\n  const [boardVisualizationMessage, setBoardVisualizationMessage] = useState('');\n  const [speed, setSpeed] = useState(5)\n  const [grid, setGrid] = useState([]);\n  const [isVisualizing, setIsVisualizing] = useState(false);\n  const timeoutID = useRef(null);\n\n  useEffect(()=>{\n    // set an empty board when the component mounts\n    freshBoard();\n    // clear the timer when the component unmounts\n    return () => {\n      if (timeoutID.current) {\n        clearTimeout(timeoutID.current);\n      }\n    };\n  }, [])\n\n  useEffect(()=>{\n    //when isVisualizing state is changed, change extra message accordingly\n    isVisualizing?setBoardVisualizationMessage(\"Board is being visualized...\"):setBoardVisualizationMessage('');\n  }, [isVisualizing])\n\n  function freshBoard() {\n\t\tconst newBoard = createBoard(HEIGHT, WIDTH, START, FINISH);\n\t\tsetGrid(newBoard);\n\t}\n//-------------------------------------------------Pathfinders related functionality-------------------------------------------------------//\n  function visualizeBreadthFirstSearchPathfinder(){\n    if(!isVisualizing){\n      setMessage(\"Pathfinding Algorithm : Breadth-First-Search\");\n      setExtraMessage(\"Breadth-First-Search is unweighted and guarantees shortest path\")\n      setIsVisualizing(true);\n      //prepare grid for the algorithm application\n      const newGrid = grid.slice();\n      prepareGridForAlgorithms(newGrid);  \n\n      //apply bfs pathfinder\n      let visitedCellsInOrder = pathfinderBFS(newGrid, getStart(newGrid), getFinish(newGrid));\n      //get nodes of shortest path backtracking from finish node\n      let shortestPathCells = getNodesInShortestPathOrder(getFinish(newGrid));\n      //check if path is possible\n      if(visitedCellsInOrder === undefined){\n        setExtraMessage(\"Path is not possible...\");\n        setIsVisualizing(false);\n        return;\n      }else{\n        //update the grid state\n        setGrid(newGrid);\n        //visualize the algorithm\n        visualize(visitedCellsInOrder, shortestPathCells);\n      } \n    }\n  }\n  function visualizeDepthFirstSearchPathfinder(){\n    if(!isVisualizing){\n      setMessage(\"Pathfinding Algorithm : Depth-First-Search\");\n      setExtraMessage(\"Depth-First-Search is unweighted and does NOT guarantee shortest path\")\n      setIsVisualizing(true);\n      //prepare grid for the algorithm application\n      const newGrid = grid.slice();\n      prepareGridForAlgorithms(newGrid);  \n      //apply bfs pathfinder\n      let visitedCellsInOrder = pathfinderDFS(newGrid, getStart(newGrid), getFinish(newGrid));\n      //get nodes of shortest path backtracking from finish node\n      let shortestPathCells = getNodesInShortestPathOrder(getFinish(newGrid));\n      //check if path is possible\n      if(visitedCellsInOrder === undefined){\n        setExtraMessage(\"Path is not possible...\");\n        setIsVisualizing(false);\n        return;\n      }else{\n        //update the grid state\n        setGrid(newGrid);\n        //visualize the algorithm\n        visualize(visitedCellsInOrder, shortestPathCells);\n      }\n    }\n  }\n\n  function visualizeDijkstraPathfinder(){\n    if(!isVisualizing){\n      setMessage(\"Pathfinding Algorithm : Dijkstra\")\n      setExtraMessage(\"Dijkstra is weighted and guarantees shortest path\")\n      setIsVisualizing(true);\n      //prepare grid for the algorithm application\n      const newGrid = grid.slice();\n      prepareGridForAlgorithms(newGrid);  \n      //apply Dijkstra pathfinder\n      let visitedCellsInOrder = pathfinderDijkstra(newGrid, getStart(newGrid), getFinish(newGrid));\n      //get nodes of shortest path backtracking from finish node\n      let shortestPathCells = getNodesInShortestPathOrder(getFinish(newGrid));\n      //check if path is possible\n      if(visitedCellsInOrder === undefined){\n        setExtraMessage(\"Path is not possible...\");\n        setIsVisualizing(false);\n        return;\n      }else{\n        //update the grid state\n        setGrid(newGrid);\n        //visualize the algorithm\n        visualize(visitedCellsInOrder, shortestPathCells);\n      }\n    }\n  }\n\n  function visualizeAstarPathfinder(){\n    if(!isVisualizing){\n      setMessage(\"Pathfinding Algorithm : A-star\")\n      setExtraMessage(\"A-star is weighted and guarantees shortest path\")\n      setIsVisualizing(true);\n      //prepare grid for the algorithm application\n      const newGrid = grid.slice();\n      prepareGridForAlgorithms(newGrid);  \n      //apply a-star pathfinder\n      let visitedCellsInOrder = pathfinderAstar(newGrid, getStart(newGrid), getFinish(newGrid));\n      //get nodes of shortest path backtracking from finish node\n      let shortestPathCells = getNodesInShortestPathOrder(getFinish(newGrid));\n      //check if path is possible\n      if(visitedCellsInOrder === undefined){\n        setExtraMessage(\"Path is not possible...\");\n        setIsVisualizing(false);\n        return;\n      }else{\n        //update the grid state\n        setGrid(newGrid);\n        //visualize the algorithm\n        visualize(visitedCellsInOrder, shortestPathCells);\n      }\n    }\n  }\n\n  function prepareGridForAlgorithms(newGrid){\n    for (const row of newGrid) {\n      for (const cell of row) {\n        //clear distance property of a cell\n        cell.distance = Infinity;\n        // explicitly clear visited cells\n        if(cell.visited){\n          cell.visited = false;\n          document.getElementById(`cell-${cell.y}-${cell.x}`).className = \"cell\";          \n        }\n        // start and finish cells are marked as visited, which in the above check got colored plain, therefore\n        //they need to be explicitly colored back to \"isStart\" and \"isFinish\" colors respectively\n        if(cell.isStart) document.getElementById(`cell-${cell.y}-${cell.x}`).className = \"cell isStart\";  \n        if(cell.isFinish) document.getElementById(`cell-${cell.y}-${cell.x}`).className = \"cell isFinish\"; \n        // if a wall was destroyed in dfs maze generation (i.e. it is both BaseWall and WallToDestroy), then remove the \n        // isBaseWall property\n        if(cell.isBaseWall && cell.isWallToDestroy) cell.isBaseWall = false;\n        // explicitly change wall colors\n        if(cell.isBaseWall) document.getElementById(`cell-${cell.y}-${cell.x}`).className = \"cell isBaseWall\"\n        if(cell.isWallToDestroy) document.getElementById(`cell-${cell.y}-${cell.x}`).className = \"cell\"\n      }\n    }\n  }\n\n  function visualize(visitedCellsInOrder, shortestPathCells){\n    //animate visited cells\n    for(let i=0; i<visitedCellsInOrder.length; i++){\n      let cell = visitedCellsInOrder[i]\n      //after all visited cells been visualized, visualize shortest path\n      if (i===visitedCellsInOrder.length-1) {\n        timeoutID.current = setTimeout(() => {\n          visualizeShortestPath(shortestPathCells);\n          setIsVisualizing(false);\n        }, speed * i);\n      } \n      timeoutID.current = setTimeout(() => {\n        if(!cell.isStart && !cell.isFinish) document.getElementById(`cell-${cell.y}-${cell.x}`).className = 'cell visited';\n      }, speed * i)\n    }\n  }\n\n  function visualizeShortestPath(shortestPathCells){\n    for(let i=1; i<shortestPathCells.length-1; i++){\n      let cell = shortestPathCells[i]\n      timeoutID.current = setTimeout(() => {\n        document.getElementById(`cell-${cell.y}-${cell.x}`).className = 'cell shortestPath';\n      }, speed * i)\n    }\n  }\n\n  function getStart(grid){\n    for(let i=0;i<grid.length;i++){\n      for(let j=0;j<grid[0].length;j++){\n          if(grid[i][j].isStart) return grid[i][j];\n      }\n    }\n    return null;\n  }\n\n  function getFinish(grid){\n    for(let i=0;i<grid.length;i++){\n      for(let j=0;j<grid[0].length;j++){\n          if(grid[i][j].isFinish) return grid[i][j];\n      }\n    }\n    return null;\n  }\n\n  // backtracks from the finishNode to find the shortest path\n  // only works when called *after* the algorithm function is executed\n  function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n\n//-------------------------------------------------Maze related functionality-------------------------------------------------------//\n\n  function visualizeDepthFirstSearchMaze(){\n\t\tif(!isVisualizing){\n      setMessage(\"Maze Generation Algorithm : Depth-First-Search\");\n\t\t\tsetIsVisualizing(true);\n      clearGrid();\n\n      // applying dfs maze generation algorithm\n      const newGrid = mazeDFS.createInitialBoardForDFS(HEIGHT, WIDTH, START, FINISH);\n\t\t\tlet visitedCellsInOrder = mazeDFS.getVisitedCellsFromDFS(newGrid);\n\n      // explicitly color BaseWall cells\n      for(let i=0;i<newGrid.length;i++){\n        for(let j=0;j<newGrid[0].length;j++){\n            if(newGrid[i][j].isBaseWall) document.getElementById(`cell-${i}-${j}`).className = \"cell isBaseWall\";\n        }\n      }\n      //update the grid state\n\t\t\tsetGrid(newGrid);\n      //animation of the maze is here\n\t\t\tfor(let i=0; i<visitedCellsInOrder.length; i++){\n\t\t\t\tlet cell = visitedCellsInOrder[i];\n        if (visitedCellsInOrder[i] === \"end\") {\n          timeoutID.current = setTimeout(() => {\n            document.getElementById(`cell-${getStart(grid).y}-${getStart(grid).x}`).className = 'cell isStart';\n            document.getElementById(`cell-${getFinish(grid).y}-${getFinish(grid).x}`).className = 'cell isFinish';\n            setIsVisualizing(false);\n          }, speed * i);\n        } \n\t\t\t\ttimeoutID.current = setTimeout(()=>{\n\t\t\t\t\tif(cell.visited || cell.isWallToDestroy ) document.getElementById(`cell-${cell.y}-${cell.x}`).className = 'cell visited'\n\t\t\t\t}, speed * i);\n\t\t\t}\n\t\t}\n\t}\n\n  function visualizeRandomMaze() {\n    if(!isVisualizing){\n      setMessage(\"Maze Generation Algorithm : Randomized\");\n\t\t\tsetIsVisualizing(true);\n      clearGrid();\n\n      // applying dfs maze generation algorithm\n      const newGrid = mazeRandom.createInitialBoardForRandomMaze(HEIGHT, WIDTH, START, FINISH);\n\t\t\tlet visitedCellsInOrder = mazeRandom.getRandomCells(newGrid);\n\n      //update the grid state\n      setGrid(newGrid);\n\n      //color randomized wall cells\n\t\t\tfor(let i=0; i<visitedCellsInOrder.length; i++){\n\t\t\t\tlet cell = visitedCellsInOrder[i];\n        if (visitedCellsInOrder[i] === \"end\") {\n            document.getElementById(`cell-${getStart(grid).y}-${getStart(grid).x}`).className = 'cell isStart';\n            document.getElementById(`cell-${getFinish(grid).y}-${getFinish(grid).x}`).className = 'cell isFinish';\n            setIsVisualizing(false);\n        } \n\t\t\t\t\tif(cell.isBaseWall ) document.getElementById(`cell-${cell.y}-${cell.x}`).className = 'cell isBaseWall'\n\t\t\t}\n\n\t\t}\n  }\n\n//-------------------------------------------------General functionality-------------------------------------------------------//\n  function clearGrid(){\n    if(!isVisualizing){\n      const newGrid = grid.slice();\n      for(let i=0;i<newGrid.length;i++){\n        for(let j=0;j<newGrid[0].length;j++){\n          if(i===START.y && j===START.x)  {\n            newGrid[i][j].isStart = true;\n            document.getElementById(`cell-${i}-${j}`).className = \"cell isStart\";\n          }\n          else if(i===FINISH.y && j===FINISH.x)  {\n            newGrid[i][j].isFinish = true;\n            document.getElementById(`cell-${i}-${j}`).className = \"cell isFinish\";\n          }\n          else{\n            newGrid[i][j].isStart = false;\n            newGrid[i][j].isFinish = false;\n            newGrid[i][j].isBaseWall = false;\n            newGrid[i][j].visited = false;\n            newGrid[i][j].isWallToDestroy = false;\n            newGrid[i][j].previousNode = null;\n            newGrid[i][j].distance = Infinity;\n            document.getElementById(`cell-${i}-${j}`).className = \"cell\";\n          } \n        }\n      }\n      setGrid(newGrid);\n    }\n  }\n\n  function handleSpeed(dropdownInfo){\n\t\tsetdropdownSpeedHeader(`Speed: ${dropdownInfo.option}`);\n\t\tif(dropdownInfo.option === \"Slow\") setSpeed(700);\n\t\tif(dropdownInfo.option === \"Medium\") setSpeed(50);\n\t\tif(dropdownInfo.option === \"Fast\") setSpeed(10);\n    if(dropdownInfo.option === \"Extra-Fast\") setSpeed(5);\n\n  }\n//-------------------------------------------------Mouse events functionality-------------------------------------------------------//\n\n//   function handleMouseDown(y, x){\n//     if(!isVisualizing){\n//       const cell = grid[y][x];\n//       if (cell.isStart === true && cell.isFinish === false) {\n//         setMainIsPressed(\"start\")      \n//         cell.isStart = false;\n//       }\n//       if (cell.isStart === false && cell.isFinish === true) {\n//         setMainIsPressed(\"finish\")      \n//         cell.isFinish = false;\n//       }\n//       if (mainIsPressed === \"\") {\n//         const newGrid = gridWithWallToggled(grid, y, x);\n//         setGrid(newGrid);\n//         setMouseIsPressed(true);\n//       }\n//     }\n   \n//   }\n//   function handleMouseEnter(y, x){\n//     if(!isVisualizing){\n//       if (mainIsPressed === \"start\") {\n//         const newGrid = gridDynamicNodes(grid, y, x, \"start\");\n//         setGrid(newGrid);\n//       }\n//       if (mainIsPressed === \"finish\") {\n//         const newGrid = gridDynamicNodes(grid, y, x, \"finish\");\n//         setGrid(newGrid);\n//       }\n//       if (mouseIsPressed && mainIsPressed === \"\") {\n//           const newGrid = gridWithWallToggled(grid, y, x);\n//           setGrid(newGrid);\n//           setMouseIsPressed(true);\n//       }\n//     }\n//   }\n\n//   function handleMouseUp(y, x){\n//     if (mainIsPressed === \"start\") {\n//       setMainIsPressed(\"\");\n//       const newGrid = gridDynamicNodes(grid, y, x, \"start\");\n//       setMainIsPressed(\"\");\n//       setStart([y, x]);\n//       setGrid(newGrid);\n//     }\n//     if (mainIsPressed === \"finish\") {\n//       const newGrid = gridDynamicNodes(grid, y, x, \"finish\");\n//       setMainIsPressed(\"\");\n//       setFinish([y, x]);\n//       setGrid(newGrid);\n//     }\n//     setMouseIsPressed(false);\n//   }\n\n//   function handleMouseLeave(y, x){\n//     if (mainIsPressed === \"\")\n//         return;\n//     let newGrid = grid.slice();\n//     const cell = newGrid[y][x];\n//     if (mainIsPressed === \"start\") {\n//         const newCell = {\n//             ...cell,\n//             isStart: false,\n//             isBaseWall: false\n//         }\n//         newGrid[y][x] = newCell;\n//     }\n//     if (mainIsPressed === \"finish\") {\n//         const newCell = {\n//             ...cell,\n//             isFinish: false,\n//             isBaseWall: false\n//         }\n//         newGrid[y][x] = newCell;\n//     }\n//     setGrid(newGrid);\n//   }\n  \n//   // updating the grid, when the walls are tiggered\n//   function gridWithWallToggled(grid, y, x){\n//     let newGrid = grid.slice();\n//     const cell = newGrid[y][x];\n//     const newCell = {\n//         ...cell,\n//         isBaseWall: (cell.isBaseWall&&cell.isWallToDestroy)?true:!cell.isBaseWall\n//     }\n//     newGrid[y][x] = newCell;\n//     return newGrid;\n//   }\n//   function gridDynamicNodes(grid, y, x, pos){\n//     let newGrid = grid.slice();\n//     const cell = newGrid[y][x];\n//     if (pos === \"start\") {\n//         const newCell = {\n//             ...cell,\n//             isStart: true\n//         }\n//         newGrid[y][x] = newCell;\n//     }\n//     if (pos === \"finish\") {\n//         const newCell = {\n//             ...cell,\n//             isFinish: true\n//         }\n//         newGrid[y][x] = newCell;\n//     }\n//     return newGrid;\n// }\n\n\n//-------------------------------------------------Returned component rendering-------------------------------------------------------//\n  if (!grid) {\n    return <div>Loading</div>;\n  }\n  return( \n        <div className=\"board\">\n          <ButtonGroup>\n            <GenerateMazeDropdown handleDFSMaze={visualizeDepthFirstSearchMaze}\n                                  handleRandomMaze={visualizeRandomMaze}/>\n            <PathfindingAlgorithmDropdown handleBFSPathfinder={visualizeBreadthFirstSearchPathfinder}\n                                          handleDFSPathfinder={visualizeDepthFirstSearchPathfinder}\n                                          handleAstarPathfinder={visualizeAstarPathfinder}\n                                          handleDijkstraPathfinder={visualizeDijkstraPathfinder} />\n            <Dropdown header={dropdownSpeedHeader}\n                      options={speedOptions}\n                      handleDropdown={handleSpeed}/>\n            <Button className={isVisualizing?\"disabled\":\"\"} color=\"info\" onClick={()=>clearGrid()}>Clear Grid</Button>\n          </ButtonGroup>\n          <h1 id=\"board-message-h1\">{message}</h1>\n          <h4>{extraMessage}</h4>\n          <h4>{boardVisualizationMessage}</h4>\n          <div className=\"grid\">\n            {grid.map((singleRow, i) => {\n              return (\n              <div className=\"grid-row\" key={i}>\n                {singleRow.map((singleBlock, i) => {\n                const {x, y, isFinish, isStart, isBaseWall} = singleBlock;\n                return <Cell  \n                              key={i}\n                              x={x}\n                              y={y}\n                              isFinish={isFinish}\n                              isStart={isStart}\n                              isBaseWall={isBaseWall} \n                             // mouseIsPressed={mouseIsPressed}\n                              // onMouseDown={(y, x) => handleMouseDown(y, x)}\n                              // onMouseEnter={(y, x) => handleMouseEnter(y, x)}\n                              // onMouseUp={(y,x) => handleMouseUp(y, x)}\n                              // onMouseLeave={(y, x) => handleMouseLeave(y, x)}\n                        />;\n                })}\n              </div>);\n            })}\n          </div>\n        </div>);\n};\n\nexport default Board;","import React from \"react\";\nimport \"./Footer.css\"\nexport default function Footer() {\n    return(\n        <footer className=\"footer\">\n            <p>Created with <span role=\"img\" aria-label=\"donut\">❤️</span> by <a href=\"https://www.linkedin.com/in/tomiris-rakhymzhan/\" > Tomiris Rakhymzhan</a></p>\n            <p>See source code <a href=\"https://github.com/tomirisrakhymzhan/find-way-my\">Github</a></p>\n        </footer>\n    );\n}","import React from 'react';\nimport Board from \"./components/Board/Board\";\nimport \"bootswatch/dist/quartz/bootstrap.min.css\";\nimport \"./App.css\";\nimport Footer from './components/Footer/Footer';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Board />\n      <Footer/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}